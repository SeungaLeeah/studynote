=============================================================
# Javascript
=============================================================



-------------------------------------------------------------
## 변수와 데이터 타입
-------------------------------------------------------------

### 전역변수

  #### 변수의 선언과 할당

    ##### var 변수이름;

    ##### 변수이름 = 값;

  #### 선언과 할당의 통합

    ##### var 변수이름 = 값;

  #### 변수값 변경하기

    ##### var num = 100;num =200;

    ##### num = 200;

  #### 변수 이름 규칙

    ##### 영어, 숫자, 언더바(_)$만 사용가능

    ##### 첫 글자는 숫자로 시작 불가능

    ##### 두 개 이상의 단어를 결합한 경우

      ###### 스네이크 표기법

       ###### 띄어쓰기 자리에 언더바(_) 사용

      ###### 카멜 표기법

       ###### 띄어쓰기 위치 첫 글자 대문자로 변경 ex) homeWork



### 지역변수

  #### 변수의 선언과 할당

    ##### 선언

      ###### let 변수이름;

    ##### 할당

      ###### 변수이름 = 값;

  #### 션언과 할당의 통합

    ##### let 변수이름 = 값;

  #### 중복 선언 금지

    ##### let 키워드는 중복 선언 불가능



### 상수

  #### const 변수이름 = 값;

  #### 선언과 동시에 값이 할당 되어야 하며,최초 값 할당 후 값 변경 불가능



### 변수의 자료형(데이터 타입)

  #### number

    ##### 정수와 실수를 포함한 모든 숫자

  #### string

    ##### 문자열, "", '',로 감싼 모든 형식 데이터

  #### boolean

    ##### 논리형 true(참) false(거짓)

  #### object

    ##### 객체, 함수(function), 배열(Array), 날짜(date), 정규식(RegExp)등

  #### null

    ##### object형의 한 종류. 나중에 할당하기 위해 비워둔 값

  #### undefined

    ##### 선언만 하고 정의되지 않은 상태




-------------------------------------------------------------
## 연산자
-------------------------------------------------------------

### 산술 연산자

  #### 산술 연산자의 종류

    ##### + 뎃셈

    ##### - 뺄셈

    ##### * 곱셈

    ##### / 나눗셈

    ##### % 나눗셈에서 정수 부분의 몫을 제외한 나머지

  #### 연산자의 활용

    ##### console.log()명령을 통해 변수간의 연산 결과 출력

    ##### 연산 결과를 새로운 변수에 할당



### 대입 연산자

  #### 좌변에 우변을 대입하는 = 연산자

    ##### 연산 결과를 새로운 변수에 대입

    ##### 이미 생성된 변수의 값을 다른 값으로 변경

    ##### 연산 결과를 변수 스스로에게 덮어 씌우기



### 단항 연산자

  #### 어떤 변수에 대한 연산 결과를 다시 변수에 덮어 씌우는 연산

    ##### +=, -=, *=, /=, %=



### 증감 연산자

  #### 연산되어지는 값이 1인 경우 한해서 1씩 증가 및 감소

    ##### 전위 증가 및 감소

      ###### 전체 수식 처리 후, 증감,감소 연산자 수행

             - x+=1, x++x-=,x--

    ##### 후위 증가 및 감소

      ###### 변수 스스로 값에 대해 증가,감소 후 전체 수식 연산

             - ++x--x



### 비교 연산자

  #### 논리값(true 혹은 false)로 결정

    ##### >=, >, <=,<

    ##### 같다(==, ===) 다르다(!=, !==)

      ###### ==, !=는 내용만 비교, ===,!==는 데이터 타입까지 비교



### 논리 연산자

  #### AND (&&)

    ##### 모든 값이 true인 경우만, 결과가 true 그 외는 false

  #### OR (||)

    ##### 연산값 중 하나라도 true면 결과가 true, 모든 결과가 false일 경우 false

  #### NOT (!)

    ##### 논리형 값 true,false 값을 반대로 만듦



### 삼항 연산자

  #### let 변수 = 조건식 ? 값1 : 값2;

    ##### 값이 참인 경우 값1, 거짓인 경우 값2가 변수에 대입



### 하위 토픽

  #### 하위 토픽

    ##### 하위 토픽




-------------------------------------------------------------
## 프로그램 흐름제어
-------------------------------------------------------------

### 조건문

  #### if문

    ##### 조건식이  참인 경우 {} 블록 안 실행

      ###### if (조건식1){
	      } else(조건식2){
	      }

              => 조건이 거짓일 경우 if문 대신 else가 실행

      ###### if(조건식1){} else if(조건식2){} else(조건문3(){}}

        ###### 여러가지 경우의 수를 나열하는 조건문

  #### switch문

      ##### switch(변수){ case 1: 실행할 명령 break; }

      ###### 조건에 맞는 case블록부터 break 키워드를 만날 때까지 실행



### 반복문

  #### while문

    ##### 초기식; while(조건식) { 반복될 구문... 증감식++,--; }

      ###### ex) let i=0; while(i<10){ ... i++; }

  #### for문

    ##### for (초기식; 조건식; 증감식;) {
	  반복될 구문...
	  }

      ###### ex) for( let i=0: i<10: i++) {}




-------------------------------------------------------------
## 기본 문법 활용
-------------------------------------------------------------

### 변수의 유효성 범위( 변수의 스코프)

  #### var 키워드

    ##### 블록{} 안에서 선언된 변수는 블록 밖에서 식별됨

    ##### 블록{}이 실행되지 않은 경우, undefined

  #### let 키워드, const 키워드

    ##### 블록{} 밖에서 선언된 변수는 안으로 침투 가능함 하지만 {} 안에서 선언된 변수는 블록을 빠져나올 수 없음

  #### for문의 초기식 유효성 범위

    ##### var 키워드 선 할당 후 선언이 가능 하지만, let, const 키워드는 불가능



### if문 안에 포함된 흐름제어

  #### if-if

    ##### 특정 조건이 참인 경우, 블록 안에서 상세조건을 판별

      ###### if(조건){
	     if(조건){
	     } else if (조건){
	     }if(조건){
	     }

  #### if-for

    ##### 특정 조건이 참인 경우, 블록 안에서 반복문 수행

      ###### if(조건){
		   for (초기식; 조건식; 증감식) {
		 ...반복될 내용... 
	      }



### for문 안에서 흐름제어

  #### for-if

    ##### 반복문 안에서 반복 수행시 마다 조건을 판별

      ###### 반복문 조건값(초기에 생성한 변수)에 대한 조건 판별

  #### for-for

    ##### 이중 반복문으로 바깥 반복문 1회 수행할 때 마다, 안쪽 반복문은 처음부터 새로 시작

    ##### 안쪽 반복문의 조건식이 바깥 반복문의 조건변수를 활용, 안쪽 반복문 반복 범위에 변화를 줌

  #### 무한루트

    ##### for-if

      ###### continue: 증감식으로 이동, break: 현재 반복문 강제 종료

    ##### while-if

      ###### continue: 조건식으로으로 강제이동, break: 현재 반복문 강제 종료




-------------------------------------------------------------
## 배열
-------------------------------------------------------------

### 배열의 이해

  #### 배열의 선언과 할당

    ##### 선언과 할당이 따로있는 경우, const 선언 불가

      ###### ex) let myArr = [1,2,3,4,5];

  #### Array클래스

     ##### ex) let newArr = new Array(...)

    ###### new Array로 배열 생성시, () 안에 숫자 값이 하나일 경우 숫자 값만큼 빈 칸을 갖음-->각 칸은 undefined가 됨

  #### 인덱스: 0부터 시작하는 일련번호

    ##### ex) console.log(myArr[0])

  #### 배열의 크기

    ##### 배열의 이름.length

      ###### 역순 공식: const 변수이름= 배열이름.length -i -1;

  #### for-of문

      ##### for (const 새로운변수 of 초기값변수이름)

       ###### 초기값을 새로운 변수에 다 담는 코드



### 2차 배열

  #### 2차 배열 생성

     ##### ex) const myarr = [ [1,2,3],                	
                               [4,5,6]
	        ]

  #### 2차 배열 원소 접근

    ##### ex) myarr [행 인덱스] [열 인덱스]

  #### 2차 배열과 반복문

    ##### for-for 중첩 반복문

      ###### 바깥쪽 반복문은 행, 안쪽 반복문은 열

       ###### ex)  for(let i=0; i<10; i++){
		    for(let j=0; j< i; j++){
	           }




-------------------------------------------------------------
## JSON
-------------------------------------------------------------

### 기본 객체 정의

  #### const 객체이름 = { key:value, key2:value2...};

  #### 객체변수이름.하위변수이름 = ;



### JSON 구조

  #### 복합자료구조#

    ##### 모든 형태의 데이터 타입이 지정될 수 있음

       ###### const 객체이름 = {key:숫자, key2:문자열, ... key:[값1 값2...]};

  #### 계층구조

    ##### 단일형태의 JSON

       ##### const 객체이름 = {key: 값, key2:값};

    ##### 다른 JSON 포함한 JSON

       ###### const 객체이름 = {key: 문자열, key: 값};

    ##### 계층구조 JSON

      ###### const 객체이름={key: {key:값1, key:값2}, key:값3};

  #### 목록구조

    ##### JSON의 Value가 배열로 정의, 각 배열의 원소가또 다른 JSON형식인 경우

       ###### const 객체이름 ={key : [{key:value, key2:value2},
                                   {key3:value, key4:value}] 
	       }



### JSON확장

  #### 존재하지 않는 key를 사용하거나 다른 변수에 대입시, undefined 처리

  #### 존재하지 않는 key에 값을 대입하면 객체 확장

  #### 아무 key도 정의되지 않는 빈 객체는 나중에 내용을 덧붙일 수 있음



### JSON 반복문

  #### 선언된 변수에 객체에 있는 key값을 전부 다 저장

      ##### for(let 변수이름 in 객체이름){...}



### 깊은복사, 얇은복사

  #### 참조복사(얇은복사)

    ##### 원본 수정시, 복사본도 수정됨

      ###### 배열,JSON,객체끼리 복사는 참조처리됨

  #### 값복사(깊은복사)

    ##### 원본 수정시,  복사본은 수정안됨

      ###### 원본과 동일한 길이를 갖는 배열 생성,원소끼리 개별 복사

        ###### Object.assign(복사될곳, 복사할곳)



### 구조분해

  #### JSON 구조분해(=비구조 할당)

    ##### 구조분해 수행 및 나머지 별도 분리(...변수이름을 이용해 분리) 

      ###### ex)const dummy ={ a1:100, a2: 200, a3: 300, a4: 400};
		const {a1, a2, ...rest_b}= dummy;

  #### 배열 구조분해

    ###### 구조분해 수행 및 나머지 별도 분리

      ###### [b1, b2, ...rest_c] = [1, 2, 3, 4, 5, 6, 7, 8, 9];




-------------------------------------------------------------
## 함수
-------------------------------------------------------------

### 함수개요

  #### 함수 정의

    ##### function 함수이름(){
                  ....명령어...
                }

  #### 함수 호출

    ##### 함수이름();

  #### 함수 이름규칙

    ##### 영어, 숫자,언더바(_)의 조합을 구성대부분 '동사+명사' 형태로 카멜표기법을 사용



### 함수실행을 위한 조건값

  #### 파라미터란?함수 실행에 필요한 조건값 정의 

    ##### 파라티터 정의

      ###### function 함수이름(파라미터){
                  ....명령어...
              }

    ##### 파라미터에 전달되는 함수 호출

      ###### 함수이름(값);

    ##### 다중파라미터 정의

      ###### function 함수이름(파라미터1, 파라미터2...파라미터n){
		    ...파라미터를 위한 프로그램 구문...
	      }

    ##### 다중파라미터 함수호출

      ###### 함수이름(값1, 값2,...값n);

    ##### 함수호출시 파라미터 생략시, undefined로 식별

    ##### 파라미터의 기본값 정의

      ###### function 함수이름(파라미터1=기본값1, 파라미터2=기본값2....){
		 	......
	      }



### 리턴

  #### 함수 정의

    ##### function 함수이름(파라미터1, 파라미터2....){
		... 파라미터를 활용한 프로그램 구문...return 돌려줄 값;
          }

  #### 리턴값을 다른 변수에 할당

    ##### const 변수 = 함수이름(파라미터1, 파라미터2,.....);

  #### 조건식 활용

    ##### if(함수이름(파라미터1, 파라미터2,...파라미터n> 0 ) {
		  ...실행 될 값...
	   }

  #### 논리값 리턴하는 함수 조건식

    ##### if (함수이름(파라미터1, 파라미터2,... 파라미터n)) [
		...함수의 리턴값이 true인 경우 실행	
	   }if (!함수이름(파라미터1, 파라미터2, ...파라미터n)) {
		....함수의 리턴갑이 false인 경우 실행
	   }

  #### 리턴값 활용한 반복문

    ##### for ( let i=0; i<함수이름(파라미터1, 파라미터2... 파라미터n); i++){
			...반복될 구문...
	   }



### 함수의 또 다른 형태

  #### 함수에 변수 대입

    ##### 함수 자체가 객체 형태이기에 다른 변수에 참조 가능

      ###### function 함수이름(...){...}const 변수 = 함수이름;

  #### 익명함수

    ##### 다른 변수에 참조시킬 목적으로 함수 정의,정의 형태가 대입문이므로 {}뒤에 ;이 위치해야함

      ###### const 변수 = function (...){
			.....
		   };

  #### 화살표 함수

    ##### 기존 익명함수 문벚을 축약

      ###### 파라미터 여러 개인 함수

      ###### const 변수 = (파라미터1, 파라미터2,... 파라미터n)=> {
			...처리로직..
	     }

      ###### 파라미터가 한개인 함수 () 생략 가능

        ###### const 변수 = 파라미터 => {
		   ...처리로직...
		};

      ###### 로직이 한 줄인 경우

      ###### const 변수 =(파리미터 1, 파라미터2, ... 파라미터n)=>리턴값;

  #### 콜백함수

    ##### 목적은 확실하지만, 과정이 불분명한 경우 ex)팀과제

      ###### 직접 함수 정의

        ###### ex) function 함수이름(파라미터1, 파라미터2){
			  return 파라미터1 +파라미터2
	     	   }
		   콜백함수이름(값1, 값2, plus); 

      ###### 익명함수 형태 전달

       ###### 콜백함수이름(값1, 값2, function(파라미터1, 파라미터2){return 실행될 값;});

      ###### 화살표함수 형태

        ###### 콜백함수이름(값1,값2(파라미터1,파라미터2) => {
		     for(let i = 파라미터1; i<파라미터2; i++){
		     console.log(출력 값);
		}});

      ###### 함수 로직이 한 줄인 경우 축약된 형태

        ###### 콜백함수이름(값1, 값2,(파라미터1,파라미터2)=>console.log(출력값));

  #### 재귀함수

    ##### 함수가 처리로직 내부에서 자기 자신을 호출

      ###### f(x)= x* f(x-1), 단 f(1)=1

    ##### 피보나치수열

      ###### f(n)= f(n-1) + f(n-2)




-------------------------------------------------------------
## 프로토타입
-------------------------------------------------------------

### 객체

  #### 하나의 변수 안에 여러 속성을 저장할 수 있는 데이터 타입



### 생성자

  #### 생성자 함수정의

    ##### const 변수 = new 함수();

    ##### 아무 함수 앞에 new를 붇이면 생성자가 됨

    ##### 화살표 함수는 생서자 형식으로 사용할 수 없음

    ##### 생성자는 new 키워드에 반응함

  #### 생성자 멤버변수 포함

    ##### this.멤버변수이름 =값;

    ##### 파라미터를 멤버변수에 복사

      ######. const 생성자이름 = function(파라미터1, 파라미터2){
		   this.파라미터1:  this.파라미터2;
		   };



### 메서드

  #### prototype 속성

    ##### 정의된 생성자의 기능 확장

      ###### 생성자함수.prototype.메서드이름 = function(파라미터1, 파라미터2,...){



### getter, setter

  #### 멤버변수에 값을 간접적으로 대입하는 setter, 멤버변수의 값을 리턴받는 getter

  #### Object.defineProperty(생성자.이름.prototype, 함수이름, {getter,setter정의}

  #### getter,setter는 같은 함수 이름을 공유



### JSON 활용

  #### 생서자이름.prototype={...}




-------------------------------------------------------------
## 클래스
-------------------------------------------------------------

### 기본 코드

  #### 클래스 이름(첫 글자는 대문자로 지정)

    ##### class 클래스이름{..생성자..getter, setter..메서드}

  #### 객체 생성

    ##### const 변수이름 = new 클래스이름();

    ##### 객체.멤버변수 = 값;객체.메서드();



### 변수만 정의한 클래스

  #### 생성자 함수 안에서 this키워드를 통해 객체 안에 변수 값들을 생성

  #### 생성자 함수 constructor로 이름이 정해져 있음



### 메서드만 정의한 클래스

  #### 용도나 목적이 같은 메서드들을 별도의 클래스로 묶어둔다



### 메서드와 멤버변수를 갖는 클래스

  #### 멤버변수는 모든 메서드가 공유하는 전역변수 개념

  #### 예약어 this.를 통해서면 접근이 가능



### getter,setter

  #### 멤버변수에 값을 간접적으로 대입하는 setter, 멤버변수의 값을 리턴받는 getter

  #### 멤버변수 직접 접근을 제한하기 위해 멤버변수의 이름은 언더바(_)로 시작됨ex) this._멤버변수이름



### 상속

  #### 기본 기능 확장 클래스

    ##### 부모 기능 클래스에서 기능을 상속받아 추가로 자신이 구현하는 기능

      ###### class 부모상속이름 extends 자식클래스이름

  #### 상속 공통기능 추출

    ##### 여러 개의 클래스가 공통되는 부분을 독립적인 클래스로 추출하여, 그 클래스를 상속하여 공유



### 메서드 오버라이드

  #### 부모 클래스의 기능을 자식 클래스가 재정의

  #### 자식이 정의한 메서드에 의해 부모 메서드는 가려짐



### super 키워드

  #### 부모 클래스를 메서드 override하고 있는 자식 클래스 안에서 부모의 원래 기능 호출



### 정적 멤버 변수

  #### 클래스에 속한 변수나 함수에 static키워드를 접목하면 모든 객체가 공유할 수 있게됨  

  #### static 변수이름(함수이름)




-------------------------------------------------------------
## 모듈의 이해
-------------------------------------------------------------

### module.exports

  #### 작성된 함수를 모듈로 등록

  #### exports의 하위 속성으로 변수, JSON, 함수 추기

  #### exports  속성으로 객체 추가

  #### 클래스 자체에 모듈 추가

  #### 클래스에 대한 객체를 모듈에 추가



### require()

  #### module.exports를 통해 등록된 기능 리턴

  #### require("./파일경로이름")




-------------------------------------------------------------
## Javascript 내장기능
-------------------------------------------------------------

### isNaN

  #### 숫자가 아니면 true, 숫자이거나 변환 가능한 형식은 false

    ##### console.log(isNaN(파라미터));



### parseFloat

  #### 주어진 값에서 변환한 실수(소수점)을 리턴

    ##### console.log(parseFloat(값));



### parseInt

  #### console.log(parseInt(10진 점수값으로 변환, 몇 진법인지));



### encodeURI

  #### 주어진 문자열을 URL에 포함시키기에 적정한 형태로 인코딩(특수문자 제외)

    ##### const 변수 = encodeURI(상위변수)



### encodeURIComponent

  ##### 모든 문자열을 URL에 포함시키기 적정한 형태로 인코딩

    ##### const 변수 = encodeURIComponent(상위변수)



### setTimeout

  #### 지정된 함수를 두 번째 인자로 전달된 시간 후에 실행하도록 예약 (딜레이가능)

    ##### setTimeout(() =>{
	         ........}
		},시간(1/1000초));



### setlnerval

  #### 지정된 함수를 두 번째 인자로 전달된 시간마다 한 번씩 호출(타이머기능)

    ##### setInterval(() =>{
	        ........}
		},시간(1/1000초));

### string

  #### 파라미터로 선정된 위치의 글자를 리턴

    ##### const 변수이름 = 상위변수이름.charAt();

  #### 파라미터로 전달된 내용일 처음 나타내는 위치를 리턴

    ##### const 변수이름 = 상위변수이름.indexOf("");

  #### 파라미터로 전달된 글자가 마지막으로 나타나는 위치를 리턴

    ##### const 변수이름 = 상위변수이름.lasstIndexOf("");

  #### 지정한 시작 위치와 끝 위치 자르기

    ##### const 변수이름 = 상위변수이름.substring(시작위치, 끝위치);

  #### 모든 글자 대문자로 변환

    ##### const 변수이름 = 상위변수이름.toUpperCase();

  #### 모든 글자 소문자로 변환 

    ##### const 변수이름 = 상위변수이름.toLowerCase();

  #### 문자열 앞, 뒤 공백 지우기

    ##### const 변수이름 = 상위변수이름.trim();

  #### 문자열 안에 포함된 구분자를 기준으로 문자열을 잘라 배열로 변환

    ##### const 변수이름 = 상위변수이름.split("구분자");

  #### 첫 번째 파라미터의 내용을 두 번째 파라미터로 변경한 결과 반환

    ##### const 변수이름 = 상위변수이름.replace(파라미터1, 파라미터2);

  #### 첫 번째 파라미터와 일치파는 내용일 둘 이상일 경우 첫 번째 항목 변경

    ##### console.log(변수이름.replaceAll(파라미터1, 파라미터2));



### Math

  #### 최대값,최소값

    ##### var 변수 = Math.max(값1, 값2)

    ##### var 변수 = Math.min(값1, 값2)

  #### 소수점

    ##### 반올림

      ###### console.log("소수점 반올림:" + Math.round(변수이름));

    ##### 올림

      ###### onsole.log("소수점 올림:" + Math.ceil(변수이름));

    ##### 내림

      ###### console.log("소수점 내림:" + Math.floor(변수이름));

  #### 절대값

    ##### console.log("절대값:" +Math.abs(변수이름));

  #### 난수

    ##### 범위 난수 발생

      ###### console.log("난수:" + Math.random());

    ##### 두 수 사이의 난수 리턴

      ###### 
	function random(값, 값2) {
        return parseInt(Math.random() *(값2-값1 +1)) + 값1;
	}



### Data

  #### 날짜 부분만 나타내는 문자열 반환

    ##### console.log(date1.toDateString());

  #### Date를 나타내는 문자여 ISO 형식

    ##### console.log(date1.toISOString());

  #### 형식 문자열을 사용해 Date 문자열 생성

    ##### console.log(date1.toLocaleString());

  #### 현재 지역형식으로 날짜부분 문자열 생성

    ##### console.log(date1.toLocaleDateString());

  #### 현재 지역형식으로 시간부분 문자열 생성

    ##### console.log(date1.toLocaleTimeString());



### Number

  #### 정적속성

    #####  console.log(Number.MAX_VALUE);

    #####  console.log(Number.MIN_VALUE);

  #### 정수인지확인

    ##### console.log(Number.isInteger(값));



### Regex

  #### 문자열이 특정 조건을 충족하는지 검사하거나 특정 패턴 문자열 검색

    ##### const 변수명 = /정규표현식/변수명.test(검사할 문자열)



### Array

  #### 배열의 원소 추가, 삭제, 변경

    ##### 맨 앞에 추가

      ###### data.unshift(0,10);

    ##### 맨 끝에 추가

      ###### const 변수이름 =data.push();

    ##### 위치와 갯수에 맞게 삭제

      ###### const 변수이름 = data.splice(자를위치,갯수);

    ##### 맨 앞에 요소 삭제

      ###### const 변수이름 = data.shift();

    ##### 맨 뒤에 요소 삭제

      ###### const 변수이름 =data.pop();

  #### 배열탐색

    ##### 인덱스 from부터 시작해 item(요소)를 찾는다

      ###### 변수.indexOf(item, from)

    ##### 인덱스 from부터 시작해 item이  있는지를 검색

      ##### 변수.includes(item, from

  #### 배열검사

    ##### 전체검사

      ###### const 변수 = 상위변수이름.filter

    ##### 배열검사

      ###### const 변수 = 상위변수이름.find

  #### 배열 정렬

    ##### 변수.sort():

  #### 역순배치

    ##### 변수.reverse();




-------------------------------------------------------------
## 비동기처리
-------------------------------------------------------------

### callback hell

  #### Javascript 비동기는 콜백함수로 실행됨

  #### 콜백함수는 여러 개가 한꺼번에 작업될 수 있음



### simple promise

  #### 비동기 처리를 통해서 성공하는 부분과 실패 부분의 처리 로직을 분리하기 위해 쓰는 객체.



### async await

  #### Promise를 리턴하는 함수를 호출하기 위함

  #### 즉시 실행 함수 형태로 정의

  #### 익명함수 전체를()로 묶고 그 뒤에 호출을 위한 ()를 연달아 넣음




-------------------------------------------------------------
## 예외처리
-------------------------------------------------------------

### try,catch,finally

  #### try{...}

    ##### try{}안의 코드에 에러가 없다면 마지막 줄까지 실행

    ##### 블록 안 코드는 최소화 해야함

  #### catch(err){..}

    #### 에러가 있다면, 중단되고 catch(err)로 넘어가서 에러정보 내보내기

  #### finally{...}

    ##### 에러 여부와 상관없이 무조건 실행됨. 생략가능



### 에러객체

  #### throw

    ##### throw는 그 자체를 에러로 인식



### 예외객체를 통한 예외객체

  #### if문에 throw new Error()로 강제 에러 만들기

  ##### 함수 안에서 error가 생기면 호출 값에 책임을 물음

  ##### 에러 점검이 끝난 후 변수 값을 쓰려면 변수의 선언이 try 블록보다 상위에 있어야함



### 사용자 정의 에러

  #### error의 이름을 바꿈으로 문제의 원인을 알 수 있음



### 비동기 예외처리

  #### try~catch는 동기 방식으로 비동식 방식인 timer와 ajax에는 대응을 못함

  #### timer처리와 같은 비동식의 예외처리는 콜백함수 내부에서 처리해야함

